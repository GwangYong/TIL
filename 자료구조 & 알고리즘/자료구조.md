# 자료구조
> 정의 : 대량의 데이터를 효율적으로 관리할 수 있도록 하는 데이터의 구

<br>


## 종류
대표적으로는 배열(Array), 스택(Stack), 큐(Queue), 링크드 리스트(Linked List), 해쉬 테이블(Hash Table), 힙(Heap) 등이 존재한다.

Python에서는 대표적으로 List, tuple, set, dictionary가 존재하며, 위의 자료구조 대부분을 모두 구햔이 가능하다

![자료구](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FWOxjB%2FbtqBr89mCVp%2Fh0huntAaxC60X8ByCOKPkk%2Fimg.png)


<br>

## **배열(Array)**

- 배열은 같은 종류의 데이터를 순차적으로 나열한다.
- 데이터를 나열하고, 각 데이터를 인덱스에 대응하주며 인덱스로 데이터를 접근할 수 있도록 구성된 데이터 구조이다.
- 파이썬에서는 list로 구현이 되어있다.

- 배열의 장점:
    - 인덱스로 인한 빠른 접근이 가능하다.
    
- 배열의 단점:
    - 미리 배열의 크기를 설정해줘야 하므로, 데이터를 추가하는 것이 어렵다.
    - 데이터를 삭제 할 경우, 뒤에 있는 데이터를 앞으로 당겨와야 하는 어려움이 있다.
    
<br>
    
## **큐(Queue)**

![큐(Queue)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxXlwr%2FbtqCKAxDjvV%2Fw2Ka83zVLTsUOGLS4rmmSK%2Fimg.png)

- 먼저 넣은 데이터를 가장 먼저 꺼내는 데이터 구조이다. (줄을 서는 행위와 유사함)
- FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식으로, 스택과 꺼내는 순서가 반대이다.

- 기능
    - Enqueue : 큐에 데이터를 넣는 기능. (Python list의 append() 메서드와 유사함)
    - Dequeue : 큐에서 데이터를 꺼내는 기능. (Python list의 pop(0) 메소드와 유사함)

<br>

## **스택(Stack)**

![스택(Stack)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeJXlhV%2FbtqCIEOloxQ%2F5Kfl9PdVKpbWk7ldKV7La1%2Fimg.png)

- 가장 나중에 쌓은 데이터를 먼저 뺄 수 있는 데이터 구조
- LIFO(Last-In, Last-Out) 방식을 사용하는 구조

- 기능
    - push() : 데이터를 스택에 쌓는 기능 (Python list의 append 메소드와 같음)
    - pop() : 데이터를 스택에서 꺼내는 기능 (Python list에 같은 기능이 있음)
    
    
    ```python
    data_stack = list()
    data_stack.append(1) # [1]
    data_stack.append(2) # [1 2]
    data_stack.pop() # 2 출력
    ```

<br>

- 장점
    - 구조가 단순해서 구현이 쉽다.
    - 데이터 저장/읽기 속도가 빠르다.
    
- 단점
    - 데이터 최대 갯수를 미리 정해주어야 한다.
    - 저장 공간의 낭비가 발생할 수 있다. (미리 최대 갯수를 넣을 공간을 확보해야 하기 때문)
    
- 리스트로 스택 구현하기
```python
class ListStack:
    def __init__(self):
        self.my_list = list()

    def push(self, data):
        self.my_list.append(data)

    def pop(self):
        return self.my_list.pop()
```

<br>

## **링크드 리스트(Linked List)**

![링크드 리스트(Linked List)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0IcnJ%2FbtqCLLSYSpd%2FZ1xZQk1YIU0tkKYV6qK6Wk%2Fimg.png)

- 연결 리스트라고도 불린다.
- 배열은 정해진 크기의 공간에 데이터를 나열해야 하지만, 링크드 리스트는 정해진 크기의 공간 없이, 필요할때마다 데이터를 추가하고 삭제가 가능한 데이터 공간이다.
- 배열과 다르게 연결되지 않고, 떨어진 곳에 존재하는 데이터를 경로로 지정하여 관리하는 데이터 구조이다.

    ![링크드 리스트(Linked List_1)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4qtbL%2FbtqBqpqE4hx%2FVj37DJJ89xR2XsQHxVRZy0%2Fimg.png)

<br>

- 기능
    - 노드(Node): 데이터 저장 단위로, 데이터 값 + 포인터로 구성되어 있다.
    - 포인터(Pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보(주소)를 가지는 값을 의미함. (다음 노드가 없을 경우 null 값)
    
- 장점
    - 배열은 미리 데이터 공간을 할당해야 하지만, 링크드 리스트는 미리 데이터 공간을 할당하지 않아도 됨.

- 단점
    - 연결을 위한 별도 데이터 공간이 필요하므로, 저장공간에 대한 효율이 높지 않다.
    - 연결 정보(데이터)를 찾는데 접근성이 좋지 않으므로 속도가 느리다.
    - 중간 데이터 삭제시, 앞 뒤 데이터의 연결을 재구성하는 부가적인 작업이 필요하다.

### 파이썬으로 Node의 구현
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = Node
```

<br>

### 더블 링크드 리스트
![더블 링크드 리스트](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkEaoY%2FbtqBrB4YCtQ%2FMJUkxSZL00bhkiuiIDlZlK%2Fimg.png)

- 이중 연결 리스트라고도 한다.
- 장점: 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능함

```python
class Node:
    def __init(self, data):
        self.data = data
        self.next = None
        self.prev = None
```

기존의 링크드 리스트에서 prev라는 이전의 노드를 가리키는 변수를 추가하면 된다.

<br>

## **해쉬 테이블 (Hash Table)**

- 키(Key)와 값(Value)쌍으로 이루어진 데이터 구조
- Key를 통해 데이터를 받아오므로, 속도를 빠르게 만드는 구조이다.
- 파이썬에서는 딕셔너리(Dictionary) 타입이 해쉬 테이블과 같은 구조이다.
- 배열로 미리 Hash Table 크기만큼 생성해서 사용한다. (공간은 많이 사용하지만, 시간은 빠르다는 장점이 있다.)

<br>

- 장점
    - 데이터 저장/검색 속도가 빠르다.
    - 해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽다.
    
- 단점
    - 일반적으로 저장공간이 좀더 많이 필요하다.
    - 여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요하다. (충돌 해결 알고리즘)
    
- 시간 복잡도
    - 일반적인 경우(충돌이 없는 경우)는 O(1)
    - 최악의 경우(모든 경우에 충돌이 발생하는 경우)는 O(n)
    > 해쉬 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, 시간 복잡도는 O(1) 이라고 말할 수 있다.
    
<br>
    
### 기본 용어

- 해쉬(Hash): 임의 값을 고정 길이로 변환하는 것
- 해쉬 함수(Hash Function): 특정 연산을 이용하여 키 값을 받아서, value를 가진 공간의 주소로 바꾸어주는 함수
- 해쉬 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- 해쉬 값(Hash Value or Address): Key값을 해쉬 함수에 넣어서 얻은 주소값을 의미
- 슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간

<br>

### 충돌 해결 알고리즘
> 해쉬 테이블의 가장 큰 문제는 충돌(Collision)의 경우이다. 이 문제를 충돌(Collision) 또는 해쉬 충돌(Hash Collision) 이라고 부른다.

- Chaining 기법
    - Open Hashing(오픈 해슁) 기법 중 하나: 해쉬 테이블 저장공간 외에 공간을 더 추가해서 사용하는 방법.
    - 충돌이 발생하면, 링크드 리스트로 데이터를 추가로 뒤에 연결시키는 방법
    
- Linear Probing 기법
    - Close Hashing(폐쇠 해슁) 기법 중 하나: 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 방법
    - 충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈 공간에 저장하는 기법
    - 저장 공간의 활용도를 높이기 위한 기법이다
    
- 빈번한 충돌을 개선하는 기법
    - 해쉬 함수를 재정의 및 해쉬 테이블의 저장공간을 확대한다.
    
    
# next~~~~~~ -> 트리랑 힙 적을 차례.......... 그리고 남은 자료구조 코드짜면서 공부하자.