## 탐욕(Greedy) 알고리즘 이란?
Greedy는 `단순 무식하게`, `탐욕적으로` 문제를 푸는 알고리즘이다. 여기서 탐욕적이라는 말은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 말한다.

매 순간마다 **그 순간에 최적이라고 생각되는 것을 선택**하며 나아가고 해답에 도달하며, 현재의 선택이 **나중에 미칠 영향에 대해서는 고려하지 않는다.** 즉, 그 순간에 대해서는 최적이지만, 그 선택들이 계속되어 해답을 만들었을 경우에 그것이 최적이라고는 보장할 수 없다.

그리디 알고리즘은 `창의력`의 능력을 요구한다. 특정 문제를 만났을 때, 단순히 현재 상황에 가장 좋아 보이는 것을 선택하더라도 문제를 풀 수 있는지를 파악해야한다.

<br>

### 탐욕적 선택의 예시

<img src="https://user-images.githubusercontent.com/59376200/159645343-bb90b4fa-7aa8-4605-8b66-ba14c8cdce16.jpeg" width="600" height="400">

위의 이미지를 보면서 경로의 값들을 다 더했을 경우에 가장 큰 수를 만들어보자.

본인이 전체를 보고 선택한다면, 전체 값들을 다 더했을때 가장 큰 3 + 107 = 110으로 갈 것이다. 하지만, 그리디 알고리즘은 탐욕적으로 **현재에 가장 좋은 선택**만 하기 때문에, 3과 25를 비교하여 가장 큰 25로 갈 것이고, 그 후에는 12와 15를 비교해 가장 큰 수인 15 즉, 25 + 15 = 40이 될 것이다.

위에서 말한듯이, 이처럼 그리디 알고리즘은 현재에서는 최적의 선택을 하지만 그 선택이 해답을 만들었을 경우에 최적의 선택이라고는 보장할 수 없다는 것이다. 

<br>

## 탐욕 알고리즘 문제 해결 방법

탐욕 알고리즘은 속도가 매우 빠르기 때문에 자주 사용된다. 하지만, 계속 말하듯이 항상 최적해가 되지 않으므로 특수하 조건이 만족되어야한다.

바로 **탐욕 선택 속성(Greedy Choice Property)** 과 **최적 부분 구조(Optimal Substructure)** 이다.

- **탐욕 선택 속성(Greedy Choice Property)** : 앞의 선택이 이후의 선택에 영향을 주지 않음
- **최적 부분 구조(Optimal Substructure)** : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성됨

<br>

## 탐욕 알고리즘 예시 - 거스름돈
편의점에서 아르바이트를 한다고 생각해보자. 

손님으로 온 사람은 물건을 계산하러 왔고 가격이 N원일 경우, 거슬러 줘야할 동전의 최소 개수를 구하는 경우를 생각하자. 카운터에서 거슬러줄 수 있는 돈은 500원, 100원, 50원, 10원을 무한히 사용할 수 있다. 단, 거슬러 주어야 하는 돈은 N의 10배수이다.

#### **이때, 돈을 어떻게 해야 최소한으로 거슬러줄 수 있을까?**
바로, **가장 큰 화폐 단위부터** 돈을 거슬러주는 방법이다. 예를 들어서, 1230원 이라는 돈을 거슬러줘야 한다고 가정해보자.

우선 처음으로 500원으로 넘어가서 되는만큼 거슬러주고 100원, 50원, 10원 이렇게 거슬러 줄 수 있는 만큼 거술러주면 된다.

즉, 가장 가치가 높은 동전인 500원 1개를 먼저 거슬러주고 확인한 뒤, 아직 거슬러줄 수 있는 가격이면 다시 반복한다. 만약, 남은 가격이 더 적다면 100원 짜리 동전으로 넘어가며 반복한다.

<br>

> Reference
> - (탐욕법(그리디 알고리즘))[https://velog.io/@contea95/%ED%83%90%EC%9A%95%EB%B2%95%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98]