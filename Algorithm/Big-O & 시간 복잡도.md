## Big-O 표기법이란?

빅오 표기법은 **알고리즘의 성능을 수학적으로 표현**해주는 표기법으로, 불필요한 연산들을 제거하고 알고리즘 분석을 쉽게 할 목적으로 사용된다. 

알고리즘의 코드에는 정답이 없기 때문에 여러가지 코드가 있다. 그렇기에 더욱 간결하면서 빠른 코드를 작성해야한다. 따라서 알고리즘에서는 **시간 복잡도가 매우 중요**하다.

또한, 빅오 표기법은 보통 알고리즘의 **시간 복잡도**와 **공간 복잡도** 를 나타내는데 사용된다.

- **시간 복잡도** : 알고리즘의 **시간 효율성**을 의미 (특정 크기의 input을 받아 실행할 때 걸리는 시간을 의미)
- **공간 복잡도** : 알고리즘의 **공간(메모리)의 효율성**을 의미 (다만, 메모리의 발달로 공간 복잡도의 중요성이 낮아짐)

여기서 시간과 공간 복잡도를 나타내는 방법으로 **점근적 표기법(Asymptotic Notation)** 을 사용한다. 점근적 표기법은 알고리즘의 **수행 시간**을 표기하기 위해 불필요한 부분들을 무시하고 **필수적인 부분들에 집중** 한다.

점근적 표기법은, 아래와 같이 3가지가 있다.
- **오메가 표기법(Big-Ω Notation)** : 점근적 하한만을 알고 있을 때 사용 
- **세타 표기법(Big-θ Notation)** : 상한과 하한을 둘 다 알고 있을 때 사용
- **빅오 표기법(Big-O Notation)** : 점근적 상한만 알고 있을 때 사용

지금은 Big-O에 대해서만 알아보자.

<br>

### Big-O 특징

- Big-O 표기법은 데이터 입력값(n)의 크기에 따라 영향을 받기 때문에 **상수항같이 사소한 부분은 무시**한다. 예를 들자면, **O(3n) 을 O(n)** 으로 된다.

-  이것도 위와 비슷하다. 마찬가지로 데이터 입력값(n)에 의해 영향을 많이 받으므로, **가장 큰 영향력이 있는 것 외에는 무시**한다. 예를 들면, **O(2n^3 + n^2 + 1) 이 O(n^3)** 이 된다.

<br>

## 시간 복잡도

시간복잡도는 위에서 말한대로, 알고리즘의 **시간 효율성**을 의미한다. 간단하게 **알고리즘의 성능**을 나타낸다고 보면 될 것이다.

시간 복잡도는 이름만 보면 시간인 `분, 초` 와 같은 **실행 시간** 으로 나타낼거 같지만 그렇지 않다. 그 이유는 **하드웨어와 어떠한 언어를 사용하느냐에 따라서 속도의 차이가 있기 때문**이다. 

그래서 그 대신에, 완료까지 걸리는 **"실행의 횟수"** 로 나타낸다.

<br>

### n 값에 따른 시간 복잡도

<br>

> 코드들은 Swift 언어로 작성했습니다.

#### **O(1)**

O(1)은 가장 실행횟수가 적은 시간 복잡도가 낮은 것이다. 

```swift
func helloWorld(n: Int) {
    print("hello, World!")
}
```

O(1)은 위의 코드처럼 **n이 1개이던 100개이던 상관없이 연산 수가 증가하지 않고 일정**하다.


#### **O(n)**

O(n)은 아래의 코드처럼 반복문이 하나 있는 형태로, 입력 n의 값에 비례해서 print 출력을 반복한다.

```swift
func printAll(n: Int) {
    for _ in 0..<n {
        print("hello, world!")
}
```

이렇게 **입력 n에 비례해서 연산 수가 증가**하는 것이 O(n)이다.


#### **O(n^2)**

이번에는 반복문이 2번 있는 케이스이다. 여기서 반복문이 3번 있다면, O(n^3)이 된다.

```swift
func printTwice(n: Int) {
    for _ in 0..<n {
        for _ in 0..<n {
            print("hello, world!")
        }
    }
}
```

이번에는 **입력 n에 비례해서 ^2만큼 연산이 증가**한다. 여기서 n의 값이 3이라면, 3^2인 9가 되어서 hello, world! 가 9번 출력된다.

또한, 앞서 말한것처럼 예시로 30n^2 + 20이라고 해도 빅오 표기법으로는 **O(n^2)으로 표기**한다.

#### **O(log n), O(n log n)**

아래의 코드처럼 입력 n개를 **절반씩 제외하면서 값을 찾고 배열의 개수가 1이 될 때까지 반복**하며 찾는 방식으로하여, **시간 복잡도는 O(log n)**이 된다.

이는 아래의 예시처럼, 주로 **이진 탐색**에서 많이 사용된다.

```swift
func binarySearch(_ array: [Int], _ num: Int) -> Int {
    var low = 0
    var high = array.count - 1

    while low <= high {
        let mid = (low + high) / 2
        let guess = array[mid]

        if guess == num {
            return guess
        } else if guess > num {
            high = mid - 1
        } else {
            low = mid + 1
        }
    }
    return 0
}
```

#### **O(2^n)**

피보나치 수열에서 주로 사용된다.

```swift

```

<br>

<img width="797" alt="스크린샷 2022-02-14 오후 9 46 51" src="https://user-images.githubusercontent.com/59376200/153866863-11a19495-0cc0-49a5-89fa-f46129ea77a9.png">

이미지 출처 : https://www.bigocheatsheet.com/

**복잡도 비교**
**faster**  O(1) < O(log n) < O(n) < O (n^2) < (n^3)< O(2^n)  **slower**

<br>

> 출처 : https://blog.chulgil.me/algorithm/

<!-- 
# 추가할것들

- 각 복잡도마다 아이패드로 그려서 그래프 표시 (너무 커지는데.. 어케 줄여보자..)
- log 관련 2개랑 2^n에 피보나치 수열 공부해서 이해
- log 관련 2개랑 2^n에 피보나치 수열 코드로 예시 작성

 -->