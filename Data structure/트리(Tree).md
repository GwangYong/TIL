# 트리(Tree)란?

<img src = "https://user-images.githubusercontent.com/59376200/130935664-2fb5afb5-3518-4588-aa79-72758225fb81.png" width = "50%" height="50%">

트리(Tree)는 `계층적인 자료`를 표현하는 데 이용되는 자료구조이며, 컴퓨터의 `directory`를 예시로 들 수 있다. 실제 나무를 거꾸로 한 것과 같은 모양을 하고있어 `트리`라고 부른다.

- 트리 관련 용어
    - 루트 노드(root node): 부모가 없는 최상위 노드
    - 단말 노드(leaf node): 자식이 없는 노드
    - 크기(size): 트리에 포함된 `모든` 노드의 개수
    - 깊이(depth): 루트 노드로부터의 거리 (A는 0, 그 밑에 B와 C로 나누어지니 B와 C의 깊이는 1, 또 그 아래의 D, E, F, G는 2, ...)
    - 높이(height): 깊이 중 최대값(위의 깊이 0, 1, 2중에 가장 높은값. 즉, 루트 노드로부터 가장 멀리있는, 단말 노드중에 가장 깊은 노드.)
    - 차수(degree): 각 노드의 간선 개수(A에서 B와 C로 나눠지니까 A의 차수는 2가되며, E에서는 단말 노드이므로 차수는 0이된다.)

<br>

# 이진 트리 VS 이진 탐색 트리


## 이진 트리(Binary Tree) 

<img src = "https://user-images.githubusercontent.com/59376200/130935705-0784d3cd-d0a6-4d6f-a6e1-3d0484d3afd3.png" width = "50%" height="50%">

트리를 구성하는 노드의 branch 갯수는 0개, 1개, 2개, 3개, ... 등 여러개가 될 수 있다.

하지만, `이진 트리`는 **모든 노드가 2개의 서브 트리를 가지고 있는 트리**로, 서브 트리 또한 모두 이진 트리이다. 즉, **branch가 최대 2개인 노드로만 구성되는 트리**라는 뜻이다.

##  이진 트리 순회 방법

위 이진 트리의 이미지에 노드부터 예시를 들어보자.

- 전위 순회(Pre-order traversal): 노드, 왼쪽 자식, 오른쪽 자식 순서로 방문하는 순회 방법. `A -> B -> C`
- 중위 순회(In-order traversal): 왼쪽 자식, 노드, 오른쪽 자식 순서로 방문하는 순회 방법. *(이진 탐색 트리를 중위 순회하면 오름차순으로 정렬된 결과를 얻을 수 있다)* `B -> A -> C`
- 후위 순회(Post-order traversal): 왼쪽 자식, 오른쪽 자식, 노드 순서로 방문하는 순회 방법. `B -> C -> A`

<br>

## 이진 탐색 트리(Binary Search Tree, BST)

<img src = "https://user-images.githubusercontent.com/59376200/130935734-7bc0c30b-6a43-4fd6-b6ed-fb4363f0bcb2.png" width = "50%" height="50%">

`이진 탐색 트리`는 위의 이진 트리에 조건이 더해진 것이다.

이진 탐색 트리는 모든 노드가 **왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드**의 순서대로 값이 크다.

물론 부모 노드를 중심으로 작은 값은 왼쪽 자식 노드에, 큰 값은 오른쪽 자식 노드에 존재해야 하므로, **이진 탐색 트리의 모든 노드의 데이터 값은 중복되는 값이 존재하면 안된다.** 즉, `데이터 값은 유일`해야 한다.

**간단 정리**
- 부모 노드보다 왼쪽 자식의 노드가 작다. 
- 부모 노드보다 오른쪽 자식의 노드가 크다.
- 같은 데이터 값을 가지는 노드는 없다. (데이터 중복 X)
